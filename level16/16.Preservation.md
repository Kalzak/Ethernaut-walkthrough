## 16. Preservation
This was a very cool level that explores some interesting behaviors with the `delegatecall()` function. The following are the steps that were taken while solving the challenge.

1. The objective is to become the owner of the contract. The first thing to do is have a look all points in the contract where `owner` can be changed, and it's only ever accessed in the `constructor`. So how are we going to be able to change `owner` once assigned there are no functions to change it? We'll get back to that later but let's have a look at the rest of the contract.

2. There are two `public` functions that we are able to access and they both serve the same functionality of running a `delegatecall` to a `LibraryContract` contract. Let's explore those contracts. There are two of them that are created and then passed into the constructor when `Preservation` is created. When its function `setTime()` is called, it sets its state variable `storedTime` to the argument that was provided. On the surface this seems like a pretty secure setup but there is a flaw and it has something to do with how `delegatecall` works with this contract.

3. Before I go into explaining how the exploit fully works I'll try to quickly explain what happens when you run `delegatecall`. You run `delegatecall` you pass it a contract address and a function ID. That function in the contract you have passed it will run *while maintaining your own contracts context*. This means that if any state variables are changed within the `delegatecall` it actually makes changes to the state of the calling contract. 
    Even then, the function `setTime()` in `LibraryContract` only makes a change to `storedTime` so how are we going to have any hope of changing the owner or anything of interest?

4. The most interesting feature about `delegatecall` is that data is referenced to by `slot`, not by variable name. If you have completed some of the previous challenged you will be aware of how slots work for contract storage. To explain in basic terms, the contract that is being called by `delegatecall` has its state variables. If you change a state variable that belongs in `slot[2]`, then slot[2]` is changed on the calling contract, even if the variable name doesn't match. So this opens up a good opportunity for us.

5. Let's have a look at `LibraryContract`. There in only one state variable `storedTime` which is `uint256`. That will take up all of `slot[0]`. During a delegated call, the calling contract will have its `slot[0]` changed. We see that `slot[0]` in the calling contract is `timeZone1Library`, which means that we can overwrite the address to whatever we like. The icing on the cake here is that this address can be called with `delegatecall`. So if we can overwrite `timeZone1Library` with our own malicious contract then we can call `setFirstTime()` in `Preservation` which will run `delegatecall` on our malicious contract and we can then change the owner!

6. While making our malicious contract we have to be sure that our state variable storage will have the same arrangement as our target contract in order to change the correct slots when we want to. The source for the malicious contract is in this repo.
